---
title: OSIV 에 대하여
categories:
- java
excerpt: |
  면접 중에 JPA의 쓰기 지연에 대해 이야기 하다가 OSIV에 대한 얘기가 나왔습니다. 물론 이게 뭔지 모르는 사람이기 때문에 정리해보는걸로.
feature_text: |
  ## OSIV에 대하여
  OSIV를 속편하게 보기 
feature_image: "https://picsum.photos/2560/600?image=733"
image: "https://picsum.photos/2560/600?image=733"
---

OSIV (Open Session In View)에 대하여..
====
  
면접 중에 JPA의 쓰기 지연에 대해 이야기 하다가 OSIV에 대한 얘기가 나왔습니다. 물론 이게 뭔지 모르는 사람이기 때문에 정리해보는걸로.  
 
지연 로딩
----
  
지연 로딩은 연관된 객체를 나중에 로딩하는 JPA의 특징입니다. 실제 엔티티 대신에 프록시 객체를 생성해서 참조에 보관하고, 실제로 요청이 들어오면 프록시 뒤의 진짜 엔티티가 생성이 되어있는지 확인한다음 생성합니다. 이를 **프록시 초기화**라고 하고 처음에 단 한번 수행이 됩니다.  
그러고 나면 실제 엔티티에 접근할 수 있게 됩니다. 이는 메소드로 객체를 가져오는 시점이 아니라 접근할 때! 실행이 됩니다.
면접 때 이걸 조절하는 속성 설정 방법이 있다고 하셨는데 불행히도 몰랐고.. 지금 와서 찾아보니 즉시 로딩(EAGER) 옵션이 있습니다. 반대로 지연 로딩은 LAZY 옵션입니다. 

OSIV란?
----
  
JPA로 개발하다보면 마주하는 예외가 있습니다. LazyInitializationException 입니다. 보통 트랜잭션이 open되어 처리가 완료되고나면 view로 넘어가고 close합니다. view에서는 전달받은 객체로 렌더링을 시작하려고 보니 그 객체는
비영속성 상태인 것입니다. 즉, 영속성 컨텍스트에서 분리되어 removed 상태가 되기 전인 그 상태인거죠. 또, 연관된 객체가 없거나(지연 로딩), result의 프록시가 초기화되지 않은 상태에서 비영속성 상태로 영속성 컨텍스트의 상태가 바뀌기 때문에 뷰에서 렌더링할때 에러가 나는 것입니다.  
  
이를 해결하는 방법에는 직접 프록시 초기화, 연관된 객체를 바로 가져오도록 하는 게 있습니다. EAGER 옵션을 쓰거나 join쿼리를 써서 한꺼번에 가져오던가 하면 되는데, 그보다는 트랜잭션을 view 렌더링 시점까지
유지하자는 것이 바로 OSIV인 것입니다. 이걸 기본적으로 제공해주는 것이 스프링 부트의 spring.jpa.open-in-view 옵션입니다. 난 이걸 쓴적이 없다고 생각했는데 이미 설정이 되어있었습니다.(명시적으로도, 스프링 부트 기본적으로도)
다만, 성능에 안좋다는 의견이 지배적입니다. 그래서 false를 보통 권하는 것 같습니다. 
